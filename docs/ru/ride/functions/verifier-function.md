# Функция-верификатор

**Функция-верификатор** — [функция](/ru/ride/functions) [dApp-скрипта](/ru/ride/script/script-types/dapp-script) с [аннотацией](/ru/ride/functions/annotations) `@Verifier`.

Функция-верификатор отвечает за [валидацию транзакций](/ru/blockchain/transaction/transaction-validation) и ордеров, которые отправляются с [dApp](/ru/blockchain/account/dapp).

У dApp-скрипта может быть только _одна_ функция-верификатор.

Функция-верификатор не имеет аргументов.

## Пример

``` ride
@Verifier(tx)
func verify() = {
    match tx {
        case _: Order|SetScriptTransaction =>
            sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
        case _ => false
    }
}
```

## Оптимизация обработки условий

В нашем примере в операторе match-case задано действие `sigVerify` (т.е. выполнить валидацию), которое будет выполнено, если валидируемая сущность является ордером или транзакцией установки скрипта. Помимо этого, задана ветвь для поведения по умолчанию, то есть поведения, которое будет предпринято в случае, если валидируемая сущность не является ни ордером, ни транзакцией установки скрипта. В нашем примере это `case _ => false` (т.е. запретить отправку). Приведенный пример не таит неожиданностей, однако, если в ветви по умолчанию мы укажем какое-либо другое значение, это может привести к нежелательным эффектам.

Приведём пример нерациональной верификации. Допустим, используется версия 2 языка Ride. В этой версии отсутствует Invoke script transaction. Формируя функцию-верификатор, мы можем указать `case` для всех транзакций, входящих во вторую версию языка Ride, и в качестве условия по умолчанию указать `case _ => sigVerify`.  Это условие может привести к тому, что, несмотря на отсутствие поддержки Invoke script transaction, такая транзакция всё-таки будет отправлена с аккаунта. Эксплуатация данной уязвимости может иметь неприятные (вплоть до утраты средств) последствия для владельца dApp, проявившего неосмотрительность.

Чтобы предотвратить нежелательные эффекты, помимо `case` с интересующими транзакциями

- рекомендуется задать `case` для каждой транзакции, поддерживаемой используемой версией Ride. Чтобы не перечислять все транзакции вручную, можно использовать синтаксический сахар — `case _: Transaction => ваше_действие`.
- в качестве условия по умолчанию указать `case _ => false`. См. пример ниже.

```
{-# STDLIB_VERSION 2 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

match tx {
    case t: TransferTransaction|ExchangeTransaction|MassTransferTransaction|Order => false   # запретить любой перевод средств с аккаунта
    case _: Transaction => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey) # разрешить все остальные известные типы транзакций, если подпись верна
    case _ => false  # все остальные (новые, неизвестные) типы сущностей отклонять, т.к. их нет в используемой версии языка
}
```

В результате все новые неизвестные типы транзакций, для которых не указан `case`, не смогут быть отправлены. Таким образом dApp, в котором реализована такая функция-верификатор, сможет пропускать только те транзакции, которые входят в версию Ride этого dApp.
