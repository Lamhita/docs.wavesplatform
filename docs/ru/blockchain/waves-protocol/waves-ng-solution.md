---
sidebarDepth: 2
---

# Решение Waves-NG

## 1. Пояснение

Максимальная скорость транзакций в системах блокчейна ограничена двумя параметрами: размера блока и интервала блока.

* Интервал блока определяет среднее количество времени, которое проходит между созданием блоков. Если мы сократим это время, форки будут появляться чаще, что приведет либо к неразрешенным форкам, либо к снижению пропускной способности, поскольку на разрешение форков будет затрачено значительное количество времени.

* Большие блоки приводят к огромным скачкам нагрузки на сеть при распространении блоков, что, в свою очередь, приводит к проблемам с пропускной способностью и огромным форкам.

**Примечание:** Waves-NG протокол подробно описан [**тут**](/en/blockchain/waves-protocol/waves-ng-protocol).

### 1.1 Технические детали решения Waves-NG

Waves решает эту проблему, позволяя майнеру непрерывно обрабатывать блок во время майнинга. Этот непрерывно увеличивающийся блок называется liquid block, который становится неизменным, когда следующий блок, ссылающийся на него, создан и добавлен. Liquid блок состоит из ключевого блока и цепочки микроблоков. Процесс создания liquid блока происходит следующим образом:

* Когда нода майнера обнаруживает, что она имеет право создать блок, она создает и отправляет ключевой блок, который обычно является просто пустым блоком.

* После этого он создает и отправляет микроблоки каждые 3 секунды. Микроблок очень похож на обычный блок: это непустой пакет транзакций, который ссылается на своего родителя: предыдущий микроблок или ключевой блок.

* Микроблоки непрерывно майнятся и распространяются в сети до появления нового ключевого блока, ссылающегося на текущий liquid блок.

### 1.2 Структура микроблока

```cpp
generator: PublicKeyAccount
transactionData: Seq[Transaction]
prevResBlockSig: BlockId
totalResBlockSig: BlockId
signature: ByteStr
```

`totalResBlockSig` - это новая общая подпись блока со всеми транзакциями из blockId= `prevResBlockSig` и собственной `transactionData`. Это означает, что \_liquid block\_ состоит из 1 \_keyblock\_ and 3 \_microblock\_:

**KEYBLOCK**\(\) &lt;-**MICRO1**\(tx1,tx2\) &lt;-**MICRO2**\(tx3,tx4\) &lt;-**MICRO3**\(tx5,tx6\)

Есть 4 версии последнего блока:

| ID | Транзакции |
| :--- | :--- |
| `KEYBLOCK.uniqueId` | - |
| `MICRO1.totalResBlockSig` | tx1,tx2 |
| `MICRO2.totalResBlockSig` | tx1,tx2,tx3,tx4 |
| `MICRO3.totalResBlockSig` | tx1,tx2,tx3,tx4,tx5,tx6 |

Следующий майнер может ссылатьяс на **любой** из этих ID в своем _keyBlock_.

## 2. Экономия

Для майнера может показаться хорошей идеей сослаться на `KEYBLOCK` из предыдущего примера и упаковать все транзакции из микроблоков в свой собственный \(micro\) блок. Чтобы сделать «кражу» транзакций менее прибыльной, чем сослаться на самую известную версию liquid блока \(= последний известный микроблок\), мы изменили механизм платежей: после активации NG майнер получит 40% от комиссии от блока который он создает и 60% комиссии от блока на который он ссылается.

## 3. Связанные изменения протокола

* Новая версия блока \(= 3\), которая может содержать до 65535 транзакций и не требует сортировки транзакций.
* По умолчанию майнеры сначала создают пустой ключевой блок. Это обычный блок, распространяемый сообщением `BlockForged`, но теперь он транслируется, если он пустой.

* Микроблоки распространяются путем трансляции своего хедера для каждого узла, который его применил \(`MicroBlockInv`\) `MicroBlockInv`
  содержит проверяемую подпись, чтобы предотвратить перегрузку ноды. Микроблок будет запрошен позже через `MicroBlockRequest` и получен обратно в `MicroBlockResponse`. Микроблоки будут повторно запрошены у другой ноды, у которой он есть, если нода не отвечает.

## 4. КОнфигурация

Следующие параметры майнера могут быть настроены \(хотя лучше не изменять их, чтобы максимизировать окончательную версию вашего liquid блока в результирующей цепочке блоков\):

* Размер ключевого блока \(`maxTransactionsInKeyBlock`, default = 0\). Если его изменить, он не будет ретранслирован, и будет использоваться обычная механика запроса расширения.
* Интервал майнинга микроблока \(`microBlockInterval`, default = 3с\).
* Максимальное количество транзакций за микроблок.(`maxTransactionsInMicroBlock`, default = 200\).
* Майнер попытается сослаться на самый известный микроблок по крайней мере с `minMicroBlockAge`age \(по умолчанию = 3с\). Это необходимо для того, чтобы майнер ссылался на уже распространенный блок, чтобы его ключевой блок не потерял связь родительским.

* Механизм синхронизации микроблоков можно настроить с помощью `waitResponseTimeout` \(по умолчанию = 2с\), `processingMicroBlocksCacheTimeout` \(по умолчанию = 10с\), `invCacheTimeout` \(по умолчанию = 10с\), которые в основном представляют собой время ожидания микроблока, и время кэширования обработанных идентификаторов микроблоков и список нод, у которых есть микроблок \(по ID\).

## 5. API изменения

* После применения каждого микроблока, последний блок изменяется, что означает что `/blocks/last` и `/blocks/at/...` будут это отражать.
* `/peers/blacklisted` теперь отображает причину бана, можно очистить черный список ноды через `/peers/clearblacklist`.
* `/debug/` и `/consensus/` секции расширены, _stateHash_ не берёт в расчёт _liquid block_.
